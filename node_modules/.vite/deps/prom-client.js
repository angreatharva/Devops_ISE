import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// node_modules/prom-client/lib/util.js
var require_util = __commonJS({
  "node_modules/prom-client/lib/util.js"(exports) {
    "use strict";
    exports.getValueAsString = function getValueString(value) {
      if (Number.isNaN(value)) {
        return "Nan";
      } else if (!Number.isFinite(value)) {
        if (value < 0) {
          return "-Inf";
        } else {
          return "+Inf";
        }
      } else {
        return `${value}`;
      }
    };
    exports.removeLabels = function removeLabels(hashMap, labels) {
      const hash = hashObject(labels);
      delete hashMap[hash];
    };
    exports.setValue = function setValue(hashMap, value, labels) {
      const hash = hashObject(labels);
      hashMap[hash] = {
        value: typeof value === "number" ? value : 0,
        labels: labels || {}
      };
      return hashMap;
    };
    exports.setValueDelta = function setValueDelta(hashMap, deltaValue, labels, hash = "") {
      const value = typeof deltaValue === "number" ? deltaValue : 0;
      if (hashMap[hash]) {
        hashMap[hash].value += value;
      } else {
        hashMap[hash] = { value, labels };
      }
      return hashMap;
    };
    exports.getLabels = function(labelNames, args) {
      if (typeof args[0] === "object") {
        return args[0];
      }
      if (labelNames.length !== args.length) {
        throw new Error("Invalid number of arguments");
      }
      const acc = {};
      for (let i = 0; i < labelNames.length; i++) {
        acc[labelNames[i]] = args[i];
      }
      return acc;
    };
    function hashObject(labels) {
      let keys = Object.keys(labels);
      if (keys.length === 0) {
        return "";
      }
      if (keys.length > 1) {
        keys = keys.sort();
      }
      let hash = "";
      let i = 0;
      const size = keys.length;
      for (; i < size - 1; i++) {
        hash += `${keys[i]}:${labels[keys[i]]},`;
      }
      hash += `${keys[i]}:${labels[keys[i]]}`;
      return hash;
    }
    exports.hashObject = hashObject;
    exports.isObject = function isObject(obj) {
      return obj === Object(obj);
    };
    var Grouper = class extends Map {
      /**
       * Adds the `value` to the `key`'s array of values.
       * @param {*} key Key to set.
       * @param {*} value Value to add to `key`'s array.
       * @returns {undefined} undefined.
       */
      add(key, value) {
        if (this.has(key)) {
          this.get(key).push(value);
        } else {
          this.set(key, [value]);
        }
      }
    };
    exports.Grouper = Grouper;
  }
});

// node_modules/prom-client/lib/registry.js
var require_registry = __commonJS({
  "node_modules/prom-client/lib/registry.js"(exports, module) {
    "use strict";
    var { getValueAsString } = require_util();
    function escapeString(str) {
      return str.replace(/\n/g, "\\n").replace(/\\(?!n)/g, "\\\\");
    }
    function escapeLabelValue(str) {
      if (typeof str !== "string") {
        return str;
      }
      return escapeString(str).replace(/"/g, '\\"');
    }
    var Registry = class _Registry {
      constructor() {
        this._metrics = {};
        this._collectors = [];
        this._defaultLabels = {};
      }
      getMetricsAsArray() {
        return Object.values(this._metrics);
      }
      async getMetricAsPrometheusString(metric) {
        const item = await metric.get();
        const name = escapeString(item.name);
        const help = `# HELP ${name} ${escapeString(item.help)}`;
        const type = `# TYPE ${name} ${item.type}`;
        const defaultLabels = Object.keys(this._defaultLabels).length > 0 ? this._defaultLabels : null;
        const values = [help, type];
        for (const { metricName = item.name, value, labels = {} } of item.values || []) {
          const labelsWithDefaults = defaultLabels ? { ...labels, ...defaultLabels, ...labels } : labels;
          const formattedLabels = Object.entries(labelsWithDefaults).map(
            ([n, v]) => `${n}="${escapeLabelValue(v)}"`
          );
          const labelsString = formattedLabels.length ? `{${formattedLabels.join(",")}}` : "";
          values.push(`${metricName}${labelsString} ${getValueAsString(value)}`);
        }
        return values.join("\n");
      }
      async metrics() {
        const promises = [];
        for (const metric of this.getMetricsAsArray()) {
          promises.push(this.getMetricAsPrometheusString(metric));
        }
        const resolves = await Promise.all(promises);
        return `${resolves.join("\n\n")}
`;
      }
      registerMetric(metric) {
        if (this._metrics[metric.name] && this._metrics[metric.name] !== metric) {
          throw new Error(
            `A metric with the name ${metric.name} has already been registered.`
          );
        }
        this._metrics[metric.name] = metric;
      }
      clear() {
        this._metrics = {};
        this._defaultLabels = {};
      }
      async getMetricsAsJSON() {
        const metrics = [];
        const defaultLabelNames = Object.keys(this._defaultLabels);
        const promises = [];
        for (const metric of this.getMetricsAsArray()) {
          promises.push(metric.get());
        }
        const resolves = await Promise.all(promises);
        for (const item of resolves) {
          if (item.values && defaultLabelNames.length > 0) {
            for (const val of item.values) {
              val.labels = Object.assign({}, val.labels);
              for (const labelName of defaultLabelNames) {
                val.labels[labelName] = val.labels[labelName] || this._defaultLabels[labelName];
              }
            }
          }
          metrics.push(item);
        }
        return metrics;
      }
      removeSingleMetric(name) {
        delete this._metrics[name];
      }
      getSingleMetricAsString(name) {
        return this.getMetricAsPrometheusString(this._metrics[name]);
      }
      getSingleMetric(name) {
        return this._metrics[name];
      }
      setDefaultLabels(labels) {
        this._defaultLabels = labels;
      }
      resetMetrics() {
        for (const metric in this._metrics) {
          this._metrics[metric].reset();
        }
      }
      get contentType() {
        return "text/plain; version=0.0.4; charset=utf-8";
      }
      static merge(registers) {
        const mergedRegistry = new _Registry();
        const metricsToMerge = registers.reduce(
          (acc, reg) => acc.concat(reg.getMetricsAsArray()),
          []
        );
        metricsToMerge.forEach(mergedRegistry.registerMetric, mergedRegistry);
        return mergedRegistry;
      }
    };
    module.exports = Registry;
    module.exports.globalRegistry = new Registry();
  }
});

// browser-external:util
var require_util2 = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/validation.js
var require_validation = __commonJS({
  "node_modules/prom-client/lib/validation.js"(exports) {
    "use strict";
    var util = require_util2();
    var metricRegexp = /^[a-zA-Z_:][a-zA-Z0-9_:]*$/;
    var labelRegexp = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
    exports.validateMetricName = function(name) {
      return metricRegexp.test(name);
    };
    exports.validateLabelName = function(names = []) {
      return names.every((name) => labelRegexp.test(name));
    };
    exports.validateLabel = function validateLabel(savedLabels, labels) {
      for (const label in labels) {
        if (!savedLabels.includes(label)) {
          throw new Error(
            `Added label "${label}" is not included in initial labelset: ${util.inspect(
              savedLabels
            )}`
          );
        }
      }
    };
  }
});

// node_modules/prom-client/lib/metric.js
var require_metric = __commonJS({
  "node_modules/prom-client/lib/metric.js"(exports, module) {
    "use strict";
    var { globalRegistry } = require_registry();
    var { isObject } = require_util();
    var { validateMetricName, validateLabelName } = require_validation();
    var Metric = class {
      constructor(config, defaults = {}) {
        if (!isObject(config)) {
          throw new TypeError("constructor expected a config object");
        }
        Object.assign(
          this,
          {
            labelNames: [],
            registers: [globalRegistry],
            aggregator: "sum"
          },
          defaults,
          config
        );
        if (!this.registers) {
          this.registers = [globalRegistry];
        }
        if (!this.help) {
          throw new Error("Missing mandatory help parameter");
        }
        if (!this.name) {
          throw new Error("Missing mandatory name parameter");
        }
        if (!validateMetricName(this.name)) {
          throw new Error("Invalid metric name");
        }
        if (!validateLabelName(this.labelNames)) {
          throw new Error("Invalid label name");
        }
        if (this.collect && typeof this.collect !== "function") {
          throw new Error('Optional "collect" parameter must be a function');
        }
        this.reset();
        for (const register of this.registers) {
          register.registerMetric(this);
        }
      }
      reset() {
      }
    };
    module.exports = { Metric };
  }
});

// node_modules/prom-client/lib/counter.js
var require_counter = __commonJS({
  "node_modules/prom-client/lib/counter.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var type = "counter";
    var { hashObject, isObject, getLabels, removeLabels } = require_util();
    var { validateLabel } = require_validation();
    var { Metric } = require_metric();
    var Counter = class extends Metric {
      /**
       * Increment counter
       * @param {object} labels - What label you want to be incremented
       * @param {Number} value - Value to increment, if omitted increment with 1
       * @returns {void}
       */
      inc(labels, value) {
        let hash;
        if (isObject(labels)) {
          hash = hashObject(labels);
          validateLabel(this.labelNames, labels);
        } else {
          value = labels;
          labels = {};
        }
        if (value && !Number.isFinite(value)) {
          throw new TypeError(`Value is not a valid number: ${util.format(value)}`);
        }
        if (value < 0) {
          throw new Error("It is not possible to decrease a counter");
        }
        if (value === null || value === void 0) value = 1;
        setValue(this.hashMap, value, labels, hash);
      }
      /**
       * Reset counter
       * @returns {void}
       */
      reset() {
        this.hashMap = {};
        if (this.labelNames.length === 0) {
          setValue(this.hashMap, 0);
        }
      }
      async get() {
        if (this.collect) {
          const v = this.collect();
          if (v instanceof Promise) await v;
        }
        return {
          help: this.help,
          name: this.name,
          type,
          values: Object.values(this.hashMap),
          aggregator: this.aggregator
        };
      }
      labels(...args) {
        const labels = getLabels(this.labelNames, args) || {};
        return {
          inc: this.inc.bind(this, labels)
        };
      }
      remove(...args) {
        const labels = getLabels(this.labelNames, args) || {};
        validateLabel(this.labelNames, labels);
        return removeLabels.call(this, this.hashMap, labels);
      }
    };
    function setValue(hashMap, value, labels = {}, hash = "") {
      if (hashMap[hash]) {
        hashMap[hash].value += value;
      } else {
        hashMap[hash] = { value, labels };
      }
      return hashMap;
    }
    module.exports = Counter;
  }
});

// node_modules/prom-client/lib/gauge.js
var require_gauge = __commonJS({
  "node_modules/prom-client/lib/gauge.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var type = "gauge";
    var {
      setValue,
      setValueDelta,
      getLabels,
      hashObject,
      isObject,
      removeLabels
    } = require_util();
    var { validateLabel } = require_validation();
    var { Metric } = require_metric();
    var Gauge = class extends Metric {
      /**
       * Set a gauge to a value
       * @param {object} labels - Object with labels and their values
       * @param {Number} value - Value to set the gauge to, must be positive
       * @returns {void}
       */
      set(labels, value) {
        value = getValueArg(labels, value);
        labels = getLabelArg(labels);
        set(this, labels, value);
      }
      /**
       * Reset gauge
       * @returns {void}
       */
      reset() {
        this.hashMap = {};
        if (this.labelNames.length === 0) {
          setValue(this.hashMap, 0, {});
        }
      }
      /**
       * Increment a gauge value
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @param {Number} value - Value to increment - if omitted, increment with 1
       * @returns {void}
       */
      inc(labels, value) {
        value = getValueArg(labels, value);
        labels = getLabelArg(labels);
        if (value === void 0) value = 1;
        setDelta(this, labels, value);
      }
      /**
       * Decrement a gauge value
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @param {Number} value - Value to decrement - if omitted, decrement with 1
       * @returns {void}
       */
      dec(labels, value) {
        value = getValueArg(labels, value);
        labels = getLabelArg(labels);
        if (value === void 0) value = 1;
        setDelta(this, labels, -value);
      }
      /**
       * Set the gauge to current unix epoch
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @returns {void}
       */
      setToCurrentTime(labels) {
        const now = Date.now() / 1e3;
        if (labels === void 0) {
          this.set(now);
        } else {
          this.set(labels, now);
        }
      }
      /**
       * Start a timer
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @returns {function} - Invoke this function to set the duration in seconds since you started the timer.
       * @example
       * var done = gauge.startTimer();
       * makeXHRRequest(function(err, response) {
       *	done(); //Duration of the request will be saved
       * });
       */
      startTimer(labels) {
        const start = process.hrtime();
        return (endLabels) => {
          const delta = process.hrtime(start);
          const value = delta[0] + delta[1] / 1e9;
          this.set(Object.assign({}, labels, endLabels), value);
          return value;
        };
      }
      async get() {
        if (this.collect) {
          const v = this.collect();
          if (v instanceof Promise) await v;
        }
        return {
          help: this.help,
          name: this.name,
          type,
          values: Object.values(this.hashMap),
          aggregator: this.aggregator
        };
      }
      _getValue(labels) {
        const hash = hashObject(labels || {});
        return this.hashMap[hash] ? this.hashMap[hash].value : 0;
      }
      labels(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        return {
          inc: this.inc.bind(this, labels),
          dec: this.dec.bind(this, labels),
          set: this.set.bind(this, labels),
          setToCurrentTime: this.setToCurrentTime.bind(this, labels),
          startTimer: this.startTimer.bind(this, labels)
        };
      }
      remove(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        removeLabels.call(this, this.hashMap, labels);
      }
    };
    function set(gauge, labels, value) {
      if (typeof value !== "number") {
        throw new TypeError(`Value is not a valid number: ${util.format(value)}`);
      }
      validateLabel(gauge.labelNames, labels);
      setValue(gauge.hashMap, value, labels);
    }
    function setDelta(gauge, labels, delta) {
      if (typeof delta !== "number") {
        throw new TypeError(`Delta is not a valid number: ${util.format(delta)}`);
      }
      validateLabel(gauge.labelNames, labels);
      const hash = hashObject(labels);
      setValueDelta(gauge.hashMap, delta, labels, hash);
    }
    function getLabelArg(labels) {
      return isObject(labels) ? labels : {};
    }
    function getValueArg(labels, value) {
      return isObject(labels) ? value : labels;
    }
    module.exports = Gauge;
  }
});

// node_modules/prom-client/lib/histogram.js
var require_histogram = __commonJS({
  "node_modules/prom-client/lib/histogram.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var type = "histogram";
    var { getLabels, hashObject, isObject, removeLabels } = require_util();
    var { validateLabel } = require_validation();
    var { Metric } = require_metric();
    var Histogram = class extends Metric {
      constructor(config) {
        super(config, {
          buckets: [5e-3, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]
        });
        for (const label of this.labelNames) {
          if (label === "le") {
            throw new Error("le is a reserved label keyword");
          }
        }
        this.upperBounds = this.buckets;
        this.bucketValues = this.upperBounds.reduce((acc, upperBound) => {
          acc[upperBound] = 0;
          return acc;
        }, {});
        Object.freeze(this.bucketValues);
        Object.freeze(this.upperBounds);
        if (this.labelNames.length === 0) {
          this.hashMap = {
            [hashObject({})]: createBaseValues(
              {},
              Object.assign({}, this.bucketValues)
            )
          };
        }
      }
      /**
       * Observe a value in histogram
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @param {Number} value - Value to observe in the histogram
       * @returns {void}
       */
      observe(labels, value) {
        observe.call(this, labels === 0 ? 0 : labels || {})(value);
      }
      async get() {
        if (this.collect) {
          const v = this.collect();
          if (v instanceof Promise) await v;
        }
        const data = Object.values(this.hashMap);
        const values = data.map(extractBucketValuesForExport(this)).reduce(addSumAndCountForExport(this), []);
        return {
          name: this.name,
          help: this.help,
          type,
          values,
          aggregator: this.aggregator
        };
      }
      reset() {
        this.hashMap = {};
      }
      /**
       * Initialize the metrics for the given combination of labels to zero
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @returns {void}
       */
      zero(labels) {
        const hash = hashObject(labels);
        this.hashMap[hash] = createBaseValues(
          labels,
          Object.assign({}, this.bucketValues)
        );
      }
      /**
       * Start a timer that could be used to logging durations
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds
       * @example
       * var end = histogram.startTimer();
       * makeExpensiveXHRRequest(function(err, res) {
       * 	const duration = end(); //Observe the duration of expensiveXHRRequest and returns duration in seconds
       * 	console.log('Duration', duration);
       * });
       */
      startTimer(labels) {
        return startTimer.call(this, labels)();
      }
      labels(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        return {
          observe: observe.call(this, labels),
          startTimer: startTimer.call(this, labels)
        };
      }
      remove(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        removeLabels.call(this, this.hashMap, labels);
      }
    };
    function startTimer(startLabels) {
      return () => {
        const start = process.hrtime();
        return (endLabels) => {
          const delta = process.hrtime(start);
          const value = delta[0] + delta[1] / 1e9;
          this.observe(Object.assign({}, startLabels, endLabels), value);
          return value;
        };
      };
    }
    function setValuePair(labels, value, metricName) {
      return {
        labels,
        value,
        metricName
      };
    }
    function findBound(upperBounds, value) {
      for (let i = 0; i < upperBounds.length; i++) {
        const bound = upperBounds[i];
        if (value <= bound) {
          return bound;
        }
      }
      return -1;
    }
    function observe(labels) {
      return (value) => {
        const labelValuePair = convertLabelsAndValues(labels, value);
        validateLabel(this.labelNames, labelValuePair.labels);
        if (!Number.isFinite(labelValuePair.value)) {
          throw new TypeError(
            `Value is not a valid number: ${util.format(labelValuePair.value)}`
          );
        }
        const hash = hashObject(labelValuePair.labels);
        let valueFromMap = this.hashMap[hash];
        if (!valueFromMap) {
          valueFromMap = createBaseValues(
            labelValuePair.labels,
            Object.assign({}, this.bucketValues)
          );
        }
        const b = findBound(this.upperBounds, labelValuePair.value);
        valueFromMap.sum += labelValuePair.value;
        valueFromMap.count += 1;
        if (Object.prototype.hasOwnProperty.call(valueFromMap.bucketValues, b)) {
          valueFromMap.bucketValues[b] += 1;
        }
        this.hashMap[hash] = valueFromMap;
      };
    }
    function createBaseValues(labels, bucketValues) {
      return {
        labels,
        bucketValues,
        sum: 0,
        count: 0
      };
    }
    function convertLabelsAndValues(labels, value) {
      if (!isObject(labels)) {
        return {
          value: labels,
          labels: {}
        };
      }
      return {
        labels,
        value
      };
    }
    function extractBucketValuesForExport(histogram) {
      return (bucketData) => {
        const buckets = [];
        const bucketLabelNames = Object.keys(bucketData.labels);
        let acc = 0;
        for (const upperBound of histogram.upperBounds) {
          acc += bucketData.bucketValues[upperBound];
          const lbls = { le: upperBound };
          for (const labelName of bucketLabelNames) {
            lbls[labelName] = bucketData.labels[labelName];
          }
          buckets.push(setValuePair(lbls, acc, `${histogram.name}_bucket`));
        }
        return { buckets, data: bucketData };
      };
    }
    function addSumAndCountForExport(histogram) {
      return (acc, d) => {
        acc.push(...d.buckets);
        const infLabel = { le: "+Inf" };
        for (const label of Object.keys(d.data.labels)) {
          infLabel[label] = d.data.labels[label];
        }
        acc.push(
          setValuePair(infLabel, d.data.count, `${histogram.name}_bucket`),
          setValuePair(d.data.labels, d.data.sum, `${histogram.name}_sum`),
          setValuePair(d.data.labels, d.data.count, `${histogram.name}_count`)
        );
        return acc;
      };
    }
    module.exports = Histogram;
  }
});

// node_modules/bintrees/lib/treebase.js
var require_treebase = __commonJS({
  "node_modules/bintrees/lib/treebase.js"(exports, module) {
    function TreeBase() {
    }
    TreeBase.prototype.clear = function() {
      this._root = null;
      this.size = 0;
    };
    TreeBase.prototype.find = function(data) {
      var res = this._root;
      while (res !== null) {
        var c = this._comparator(data, res.data);
        if (c === 0) {
          return res.data;
        } else {
          res = res.get_child(c > 0);
        }
      }
      return null;
    };
    TreeBase.prototype.findIter = function(data) {
      var res = this._root;
      var iter = this.iterator();
      while (res !== null) {
        var c = this._comparator(data, res.data);
        if (c === 0) {
          iter._cursor = res;
          return iter;
        } else {
          iter._ancestors.push(res);
          res = res.get_child(c > 0);
        }
      }
      return null;
    };
    TreeBase.prototype.lowerBound = function(item) {
      var cur = this._root;
      var iter = this.iterator();
      var cmp = this._comparator;
      while (cur !== null) {
        var c = cmp(item, cur.data);
        if (c === 0) {
          iter._cursor = cur;
          return iter;
        }
        iter._ancestors.push(cur);
        cur = cur.get_child(c > 0);
      }
      for (var i = iter._ancestors.length - 1; i >= 0; --i) {
        cur = iter._ancestors[i];
        if (cmp(item, cur.data) < 0) {
          iter._cursor = cur;
          iter._ancestors.length = i;
          return iter;
        }
      }
      iter._ancestors.length = 0;
      return iter;
    };
    TreeBase.prototype.upperBound = function(item) {
      var iter = this.lowerBound(item);
      var cmp = this._comparator;
      while (iter.data() !== null && cmp(iter.data(), item) === 0) {
        iter.next();
      }
      return iter;
    };
    TreeBase.prototype.min = function() {
      var res = this._root;
      if (res === null) {
        return null;
      }
      while (res.left !== null) {
        res = res.left;
      }
      return res.data;
    };
    TreeBase.prototype.max = function() {
      var res = this._root;
      if (res === null) {
        return null;
      }
      while (res.right !== null) {
        res = res.right;
      }
      return res.data;
    };
    TreeBase.prototype.iterator = function() {
      return new Iterator(this);
    };
    TreeBase.prototype.each = function(cb) {
      var it = this.iterator(), data;
      while ((data = it.next()) !== null) {
        if (cb(data) === false) {
          return;
        }
      }
    };
    TreeBase.prototype.reach = function(cb) {
      var it = this.iterator(), data;
      while ((data = it.prev()) !== null) {
        if (cb(data) === false) {
          return;
        }
      }
    };
    function Iterator(tree) {
      this._tree = tree;
      this._ancestors = [];
      this._cursor = null;
    }
    Iterator.prototype.data = function() {
      return this._cursor !== null ? this._cursor.data : null;
    };
    Iterator.prototype.next = function() {
      if (this._cursor === null) {
        var root = this._tree._root;
        if (root !== null) {
          this._minNode(root);
        }
      } else {
        if (this._cursor.right === null) {
          var save;
          do {
            save = this._cursor;
            if (this._ancestors.length) {
              this._cursor = this._ancestors.pop();
            } else {
              this._cursor = null;
              break;
            }
          } while (this._cursor.right === save);
        } else {
          this._ancestors.push(this._cursor);
          this._minNode(this._cursor.right);
        }
      }
      return this._cursor !== null ? this._cursor.data : null;
    };
    Iterator.prototype.prev = function() {
      if (this._cursor === null) {
        var root = this._tree._root;
        if (root !== null) {
          this._maxNode(root);
        }
      } else {
        if (this._cursor.left === null) {
          var save;
          do {
            save = this._cursor;
            if (this._ancestors.length) {
              this._cursor = this._ancestors.pop();
            } else {
              this._cursor = null;
              break;
            }
          } while (this._cursor.left === save);
        } else {
          this._ancestors.push(this._cursor);
          this._maxNode(this._cursor.left);
        }
      }
      return this._cursor !== null ? this._cursor.data : null;
    };
    Iterator.prototype._minNode = function(start) {
      while (start.left !== null) {
        this._ancestors.push(start);
        start = start.left;
      }
      this._cursor = start;
    };
    Iterator.prototype._maxNode = function(start) {
      while (start.right !== null) {
        this._ancestors.push(start);
        start = start.right;
      }
      this._cursor = start;
    };
    module.exports = TreeBase;
  }
});

// node_modules/bintrees/lib/rbtree.js
var require_rbtree = __commonJS({
  "node_modules/bintrees/lib/rbtree.js"(exports, module) {
    var TreeBase = require_treebase();
    function Node(data) {
      this.data = data;
      this.left = null;
      this.right = null;
      this.red = true;
    }
    Node.prototype.get_child = function(dir) {
      return dir ? this.right : this.left;
    };
    Node.prototype.set_child = function(dir, val) {
      if (dir) {
        this.right = val;
      } else {
        this.left = val;
      }
    };
    function RBTree(comparator) {
      this._root = null;
      this._comparator = comparator;
      this.size = 0;
    }
    RBTree.prototype = new TreeBase();
    RBTree.prototype.insert = function(data) {
      var ret2 = false;
      if (this._root === null) {
        this._root = new Node(data);
        ret2 = true;
        this.size++;
      } else {
        var head = new Node(void 0);
        var dir = 0;
        var last = 0;
        var gp = null;
        var ggp = head;
        var p = null;
        var node = this._root;
        ggp.right = this._root;
        while (true) {
          if (node === null) {
            node = new Node(data);
            p.set_child(dir, node);
            ret2 = true;
            this.size++;
          } else if (is_red(node.left) && is_red(node.right)) {
            node.red = true;
            node.left.red = false;
            node.right.red = false;
          }
          if (is_red(node) && is_red(p)) {
            var dir2 = ggp.right === gp;
            if (node === p.get_child(last)) {
              ggp.set_child(dir2, single_rotate(gp, !last));
            } else {
              ggp.set_child(dir2, double_rotate(gp, !last));
            }
          }
          var cmp = this._comparator(node.data, data);
          if (cmp === 0) {
            break;
          }
          last = dir;
          dir = cmp < 0;
          if (gp !== null) {
            ggp = gp;
          }
          gp = p;
          p = node;
          node = node.get_child(dir);
        }
        this._root = head.right;
      }
      this._root.red = false;
      return ret2;
    };
    RBTree.prototype.remove = function(data) {
      if (this._root === null) {
        return false;
      }
      var head = new Node(void 0);
      var node = head;
      node.right = this._root;
      var p = null;
      var gp = null;
      var found = null;
      var dir = 1;
      while (node.get_child(dir) !== null) {
        var last = dir;
        gp = p;
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;
        if (cmp === 0) {
          found = node;
        }
        if (!is_red(node) && !is_red(node.get_child(dir))) {
          if (is_red(node.get_child(!dir))) {
            var sr = single_rotate(node, dir);
            p.set_child(last, sr);
            p = sr;
          } else if (!is_red(node.get_child(!dir))) {
            var sibling = p.get_child(!last);
            if (sibling !== null) {
              if (!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {
                p.red = false;
                sibling.red = true;
                node.red = true;
              } else {
                var dir2 = gp.right === p;
                if (is_red(sibling.get_child(last))) {
                  gp.set_child(dir2, double_rotate(p, last));
                } else if (is_red(sibling.get_child(!last))) {
                  gp.set_child(dir2, single_rotate(p, last));
                }
                var gpc = gp.get_child(dir2);
                gpc.red = true;
                node.red = true;
                gpc.left.red = false;
                gpc.right.red = false;
              }
            }
          }
        }
      }
      if (found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this.size--;
      }
      this._root = head.right;
      if (this._root !== null) {
        this._root.red = false;
      }
      return found !== null;
    };
    function is_red(node) {
      return node !== null && node.red;
    }
    function single_rotate(root, dir) {
      var save = root.get_child(!dir);
      root.set_child(!dir, save.get_child(dir));
      save.set_child(dir, root);
      root.red = true;
      save.red = false;
      return save;
    }
    function double_rotate(root, dir) {
      root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));
      return single_rotate(root, dir);
    }
    module.exports = RBTree;
  }
});

// node_modules/bintrees/lib/bintree.js
var require_bintree = __commonJS({
  "node_modules/bintrees/lib/bintree.js"(exports, module) {
    var TreeBase = require_treebase();
    function Node(data) {
      this.data = data;
      this.left = null;
      this.right = null;
    }
    Node.prototype.get_child = function(dir) {
      return dir ? this.right : this.left;
    };
    Node.prototype.set_child = function(dir, val) {
      if (dir) {
        this.right = val;
      } else {
        this.left = val;
      }
    };
    function BinTree(comparator) {
      this._root = null;
      this._comparator = comparator;
      this.size = 0;
    }
    BinTree.prototype = new TreeBase();
    BinTree.prototype.insert = function(data) {
      if (this._root === null) {
        this._root = new Node(data);
        this.size++;
        return true;
      }
      var dir = 0;
      var p = null;
      var node = this._root;
      while (true) {
        if (node === null) {
          node = new Node(data);
          p.set_child(dir, node);
          ret = true;
          this.size++;
          return true;
        }
        if (this._comparator(node.data, data) === 0) {
          return false;
        }
        dir = this._comparator(node.data, data) < 0;
        p = node;
        node = node.get_child(dir);
      }
    };
    BinTree.prototype.remove = function(data) {
      if (this._root === null) {
        return false;
      }
      var head = new Node(void 0);
      var node = head;
      node.right = this._root;
      var p = null;
      var found = null;
      var dir = 1;
      while (node.get_child(dir) !== null) {
        p = node;
        node = node.get_child(dir);
        var cmp = this._comparator(data, node.data);
        dir = cmp > 0;
        if (cmp === 0) {
          found = node;
        }
      }
      if (found !== null) {
        found.data = node.data;
        p.set_child(p.right === node, node.get_child(node.left === null));
        this._root = head.right;
        this.size--;
        return true;
      } else {
        return false;
      }
    };
    module.exports = BinTree;
  }
});

// node_modules/bintrees/index.js
var require_bintrees = __commonJS({
  "node_modules/bintrees/index.js"(exports, module) {
    module.exports = {
      RBTree: require_rbtree(),
      BinTree: require_bintree()
    };
  }
});

// node_modules/tdigest/tdigest.js
var require_tdigest = __commonJS({
  "node_modules/tdigest/tdigest.js"(exports, module) {
    var RBTree = require_bintrees().RBTree;
    function TDigest(delta, K, CX) {
      this.discrete = delta === false;
      this.delta = delta || 0.01;
      this.K = K === void 0 ? 25 : K;
      this.CX = CX === void 0 ? 1.1 : CX;
      this.centroids = new RBTree(compare_centroid_means);
      this.nreset = 0;
      this.reset();
    }
    TDigest.prototype.reset = function() {
      this.centroids.clear();
      this.n = 0;
      this.nreset += 1;
      this.last_cumulate = 0;
    };
    TDigest.prototype.size = function() {
      return this.centroids.size;
    };
    TDigest.prototype.toArray = function(everything) {
      var result = [];
      if (everything) {
        this._cumulate(true);
        this.centroids.each(function(c) {
          result.push(c);
        });
      } else {
        this.centroids.each(function(c) {
          result.push({ mean: c.mean, n: c.n });
        });
      }
      return result;
    };
    TDigest.prototype.summary = function() {
      var approx = this.discrete ? "exact " : "approximating ";
      var s = [
        approx + this.n + " samples using " + this.size() + " centroids",
        "min = " + this.percentile(0),
        "Q1  = " + this.percentile(0.25),
        "Q2  = " + this.percentile(0.5),
        "Q3  = " + this.percentile(0.75),
        "max = " + this.percentile(1)
      ];
      return s.join("\n");
    };
    function compare_centroid_means(a, b) {
      return a.mean > b.mean ? 1 : a.mean < b.mean ? -1 : 0;
    }
    function compare_centroid_mean_cumns(a, b) {
      return a.mean_cumn - b.mean_cumn;
    }
    TDigest.prototype.push = function(x, n) {
      n = n || 1;
      x = Array.isArray(x) ? x : [x];
      for (var i = 0; i < x.length; i++) {
        this._digest(x[i], n);
      }
    };
    TDigest.prototype.push_centroid = function(c) {
      c = Array.isArray(c) ? c : [c];
      for (var i = 0; i < c.length; i++) {
        this._digest(c[i].mean, c[i].n);
      }
    };
    TDigest.prototype._cumulate = function(exact) {
      if (this.n === this.last_cumulate || !exact && this.CX && this.CX > this.n / this.last_cumulate) {
        return;
      }
      var cumn = 0;
      this.centroids.each(function(c) {
        c.mean_cumn = cumn + c.n / 2;
        cumn = c.cumn = cumn + c.n;
      });
      this.n = this.last_cumulate = cumn;
    };
    TDigest.prototype.find_nearest = function(x) {
      if (this.size() === 0) {
        return null;
      }
      var iter = this.centroids.lowerBound({ mean: x });
      var c = iter.data() === null ? iter.prev() : iter.data();
      if (c.mean === x || this.discrete) {
        return c;
      }
      var prev = iter.prev();
      if (prev && Math.abs(prev.mean - x) < Math.abs(c.mean - x)) {
        return prev;
      } else {
        return c;
      }
    };
    TDigest.prototype._new_centroid = function(x, n, cumn) {
      var c = { mean: x, n, cumn };
      this.centroids.insert(c);
      this.n += n;
      return c;
    };
    TDigest.prototype._addweight = function(nearest, x, n) {
      if (x !== nearest.mean) {
        nearest.mean += n * (x - nearest.mean) / (nearest.n + n);
      }
      nearest.cumn += n;
      nearest.mean_cumn += n / 2;
      nearest.n += n;
      this.n += n;
    };
    TDigest.prototype._digest = function(x, n) {
      var min = this.centroids.min();
      var max = this.centroids.max();
      var nearest = this.find_nearest(x);
      if (nearest && nearest.mean === x) {
        this._addweight(nearest, x, n);
      } else if (nearest === min) {
        this._new_centroid(x, n, 0);
      } else if (nearest === max) {
        this._new_centroid(x, n, this.n);
      } else if (this.discrete) {
        this._new_centroid(x, n, nearest.cumn);
      } else {
        var p = nearest.mean_cumn / this.n;
        var max_n = Math.floor(4 * this.n * this.delta * p * (1 - p));
        if (max_n - nearest.n >= n) {
          this._addweight(nearest, x, n);
        } else {
          this._new_centroid(x, n, nearest.cumn);
        }
      }
      this._cumulate(false);
      if (!this.discrete && this.K && this.size() > this.K / this.delta) {
        this.compress();
      }
    };
    TDigest.prototype.bound_mean = function(x) {
      var iter = this.centroids.upperBound({ mean: x });
      var lower = iter.prev();
      var upper = lower.mean === x ? lower : iter.next();
      return [lower, upper];
    };
    TDigest.prototype.p_rank = function(x_or_xlist) {
      var xs = Array.isArray(x_or_xlist) ? x_or_xlist : [x_or_xlist];
      var ps = xs.map(this._p_rank, this);
      return Array.isArray(x_or_xlist) ? ps : ps[0];
    };
    TDigest.prototype._p_rank = function(x) {
      if (this.size() === 0) {
        return void 0;
      } else if (x < this.centroids.min().mean) {
        return 0;
      } else if (x > this.centroids.max().mean) {
        return 1;
      }
      this._cumulate(true);
      var bound = this.bound_mean(x);
      var lower = bound[0], upper = bound[1];
      if (this.discrete) {
        return lower.cumn / this.n;
      } else {
        var cumn = lower.mean_cumn;
        if (lower !== upper) {
          cumn += (x - lower.mean) * (upper.mean_cumn - lower.mean_cumn) / (upper.mean - lower.mean);
        }
        return cumn / this.n;
      }
    };
    TDigest.prototype.bound_mean_cumn = function(cumn) {
      this.centroids._comparator = compare_centroid_mean_cumns;
      var iter = this.centroids.upperBound({ mean_cumn: cumn });
      this.centroids._comparator = compare_centroid_means;
      var lower = iter.prev();
      var upper = lower && lower.mean_cumn === cumn ? lower : iter.next();
      return [lower, upper];
    };
    TDigest.prototype.percentile = function(p_or_plist) {
      var ps = Array.isArray(p_or_plist) ? p_or_plist : [p_or_plist];
      var qs = ps.map(this._percentile, this);
      return Array.isArray(p_or_plist) ? qs : qs[0];
    };
    TDigest.prototype._percentile = function(p) {
      if (this.size() === 0) {
        return void 0;
      }
      this._cumulate(true);
      var h = this.n * p;
      var bound = this.bound_mean_cumn(h);
      var lower = bound[0], upper = bound[1];
      if (upper === lower || lower === null || upper === null) {
        return (lower || upper).mean;
      } else if (!this.discrete) {
        return lower.mean + (h - lower.mean_cumn) * (upper.mean - lower.mean) / (upper.mean_cumn - lower.mean_cumn);
      } else if (h <= lower.cumn) {
        return lower.mean;
      } else {
        return upper.mean;
      }
    };
    function pop_random(choices) {
      var idx = Math.floor(Math.random() * choices.length);
      return choices.splice(idx, 1)[0];
    }
    TDigest.prototype.compress = function() {
      if (this.compressing) {
        return;
      }
      var points = this.toArray();
      this.reset();
      this.compressing = true;
      while (points.length > 0) {
        this.push_centroid(pop_random(points));
      }
      this._cumulate(true);
      this.compressing = false;
    };
    function Digest(config) {
      this.config = config || {};
      this.mode = this.config.mode || "auto";
      TDigest.call(this, this.mode === "cont" ? config.delta : false);
      this.digest_ratio = this.config.ratio || 0.9;
      this.digest_thresh = this.config.thresh || 1e3;
      this.n_unique = 0;
    }
    Digest.prototype = Object.create(TDigest.prototype);
    Digest.prototype.constructor = Digest;
    Digest.prototype.push = function(x_or_xlist) {
      TDigest.prototype.push.call(this, x_or_xlist);
      this.check_continuous();
    };
    Digest.prototype._new_centroid = function(x, n, cumn) {
      this.n_unique += 1;
      TDigest.prototype._new_centroid.call(this, x, n, cumn);
    };
    Digest.prototype._addweight = function(nearest, x, n) {
      if (nearest.n === 1) {
        this.n_unique -= 1;
      }
      TDigest.prototype._addweight.call(this, nearest, x, n);
    };
    Digest.prototype.check_continuous = function() {
      if (this.mode !== "auto" || this.size() < this.digest_thresh) {
        return false;
      }
      if (this.n_unique / this.size() > this.digest_ratio) {
        this.mode = "cont";
        this.discrete = false;
        this.delta = this.config.delta || 0.01;
        this.compress();
        return true;
      }
      return false;
    };
    module.exports = {
      "TDigest": TDigest,
      "Digest": Digest
    };
  }
});

// node_modules/prom-client/lib/timeWindowQuantiles.js
var require_timeWindowQuantiles = __commonJS({
  "node_modules/prom-client/lib/timeWindowQuantiles.js"(exports, module) {
    "use strict";
    var { TDigest } = require_tdigest();
    var TimeWindowQuantiles = class {
      constructor(maxAgeSeconds, ageBuckets) {
        this.maxAgeSeconds = maxAgeSeconds || 0;
        this.ageBuckets = ageBuckets || 0;
        this.shouldRotate = maxAgeSeconds && ageBuckets;
        this.ringBuffer = Array(ageBuckets).fill(new TDigest());
        this.currentBuffer = 0;
        this.lastRotateTimestampMillis = Date.now();
        this.durationBetweenRotatesMillis = maxAgeSeconds * 1e3 / ageBuckets || Infinity;
      }
      size() {
        const bucket = rotate.call(this);
        return bucket.size();
      }
      percentile(quantile) {
        const bucket = rotate.call(this);
        return bucket.percentile(quantile);
      }
      push(value) {
        rotate.call(this);
        this.ringBuffer.forEach((bucket) => {
          bucket.push(value);
        });
      }
      reset() {
        this.ringBuffer.forEach((bucket) => {
          bucket.reset();
        });
      }
      compress() {
        this.ringBuffer.forEach((bucket) => {
          bucket.compress();
        });
      }
    };
    function rotate() {
      let timeSinceLastRotateMillis = Date.now() - this.lastRotateTimestampMillis;
      while (timeSinceLastRotateMillis > this.durationBetweenRotatesMillis && this.shouldRotate) {
        this.ringBuffer[this.currentBuffer] = new TDigest();
        if (++this.currentBuffer >= this.ringBuffer.length) {
          this.currentBuffer = 0;
        }
        timeSinceLastRotateMillis -= this.durationBetweenRotatesMillis;
        this.lastRotateTimestampMillis += this.durationBetweenRotatesMillis;
      }
      return this.ringBuffer[this.currentBuffer];
    }
    module.exports = TimeWindowQuantiles;
  }
});

// node_modules/prom-client/lib/summary.js
var require_summary = __commonJS({
  "node_modules/prom-client/lib/summary.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var type = "summary";
    var { getLabels, hashObject, removeLabels } = require_util();
    var { validateLabel } = require_validation();
    var { Metric } = require_metric();
    var timeWindowQuantiles = require_timeWindowQuantiles();
    var DEFAULT_COMPRESS_COUNT = 1e3;
    var Summary = class extends Metric {
      constructor(config) {
        super(config, {
          percentiles: [0.01, 0.05, 0.5, 0.9, 0.95, 0.99, 0.999],
          compressCount: DEFAULT_COMPRESS_COUNT,
          hashMap: {}
        });
        for (const label of this.labelNames) {
          if (label === "quantile")
            throw new Error("quantile is a reserved label keyword");
        }
        if (this.labelNames.length === 0) {
          this.hashMap = {
            [hashObject({})]: {
              labels: {},
              td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
              count: 0,
              sum: 0
            }
          };
        }
      }
      /**
       * Observe a value
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @param {Number} value - Value to observe
       * @returns {void}
       */
      observe(labels, value) {
        observe.call(this, labels === 0 ? 0 : labels || {})(value);
      }
      async get() {
        if (this.collect) {
          const v = this.collect();
          if (v instanceof Promise) await v;
        }
        const hashKeys = Object.keys(this.hashMap);
        const values = [];
        hashKeys.forEach((hashKey) => {
          const s = this.hashMap[hashKey];
          if (s) {
            if (this.pruneAgedBuckets && s.td.size() === 0) {
              delete this.hashMap[hashKey];
            } else {
              extractSummariesForExport(s, this.percentiles).forEach((v) => {
                values.push(v);
              });
              values.push(getSumForExport(s, this));
              values.push(getCountForExport(s, this));
            }
          }
        });
        return {
          name: this.name,
          help: this.help,
          type,
          values,
          aggregator: this.aggregator
        };
      }
      reset() {
        const data = Object.values(this.hashMap);
        data.forEach((s) => {
          s.td.reset();
          s.count = 0;
          s.sum = 0;
        });
      }
      /**
       * Start a timer that could be used to logging durations
       * @param {object} labels - Object with labels where key is the label key and value is label value. Can only be one level deep
       * @returns {function} - Function to invoke when you want to stop the timer and observe the duration in seconds
       * @example
       * var end = summary.startTimer();
       * makeExpensiveXHRRequest(function(err, res) {
       *	end(); //Observe the duration of expensiveXHRRequest
       * });
       */
      startTimer(labels) {
        return startTimer.call(this, labels)();
      }
      labels(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        return {
          observe: observe.call(this, labels),
          startTimer: startTimer.call(this, labels)
        };
      }
      remove(...args) {
        const labels = getLabels(this.labelNames, args);
        validateLabel(this.labelNames, labels);
        removeLabels.call(this, this.hashMap, labels);
      }
    };
    function extractSummariesForExport(summaryOfLabels, percentiles) {
      summaryOfLabels.td.compress();
      return percentiles.map((percentile) => {
        const percentileValue = summaryOfLabels.td.percentile(percentile);
        return {
          labels: Object.assign({ quantile: percentile }, summaryOfLabels.labels),
          value: percentileValue ? percentileValue : 0
        };
      });
    }
    function getCountForExport(value, summary) {
      return {
        metricName: `${summary.name}_count`,
        labels: value.labels,
        value: value.count
      };
    }
    function getSumForExport(value, summary) {
      return {
        metricName: `${summary.name}_sum`,
        labels: value.labels,
        value: value.sum
      };
    }
    function startTimer(startLabels) {
      return () => {
        const start = process.hrtime();
        return (endLabels) => {
          const delta = process.hrtime(start);
          const value = delta[0] + delta[1] / 1e9;
          this.observe(Object.assign({}, startLabels, endLabels), value);
          return value;
        };
      };
    }
    function observe(labels) {
      return (value) => {
        const labelValuePair = convertLabelsAndValues(labels, value);
        validateLabel(this.labelNames, labels);
        if (!Number.isFinite(labelValuePair.value)) {
          throw new TypeError(
            `Value is not a valid number: ${util.format(labelValuePair.value)}`
          );
        }
        const hash = hashObject(labelValuePair.labels);
        let summaryOfLabel = this.hashMap[hash];
        if (!summaryOfLabel) {
          summaryOfLabel = {
            labels: labelValuePair.labels,
            td: new timeWindowQuantiles(this.maxAgeSeconds, this.ageBuckets),
            count: 0,
            sum: 0
          };
        }
        summaryOfLabel.td.push(labelValuePair.value);
        summaryOfLabel.count++;
        if (summaryOfLabel.count % this.compressCount === 0) {
          summaryOfLabel.td.compress();
        }
        summaryOfLabel.sum += labelValuePair.value;
        this.hashMap[hash] = summaryOfLabel;
      };
    }
    function convertLabelsAndValues(labels, value) {
      if (value === void 0) {
        return {
          value: labels,
          labels: {}
        };
      }
      return {
        labels,
        value
      };
    }
    module.exports = Summary;
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/pushgateway.js
var require_pushgateway = __commonJS({
  "node_modules/prom-client/lib/pushgateway.js"(exports, module) {
    "use strict";
    var url = require_url();
    var http = require_http();
    var https = require_https();
    var { gzipSync } = require_zlib();
    var { globalRegistry } = require_registry();
    var Pushgateway = class {
      constructor(gatewayUrl, options, registry) {
        if (!registry) {
          registry = globalRegistry;
        }
        this.registry = registry;
        this.gatewayUrl = gatewayUrl;
        this.requestOptions = Object.assign({}, options);
      }
      pushAdd(params) {
        if (!params || !params.jobName) {
          throw new Error("Missing jobName parameter");
        }
        return useGateway.call(this, "POST", params.jobName, params.groupings);
      }
      push(params) {
        if (!params || !params.jobName) {
          throw new Error("Missing jobName parameter");
        }
        return useGateway.call(this, "PUT", params.jobName, params.groupings);
      }
      delete(params) {
        if (!params || !params.jobName) {
          throw new Error("Missing jobName parameter");
        }
        return useGateway.call(this, "DELETE", params.jobName, params.groupings);
      }
    };
    async function useGateway(method, job, groupings) {
      const gatewayUrlParsed = url.parse(this.gatewayUrl);
      const gatewayUrlPath = gatewayUrlParsed.pathname && gatewayUrlParsed.pathname !== "/" ? gatewayUrlParsed.pathname : "";
      const path = `${gatewayUrlPath}/metrics/job/${encodeURIComponent(
        job
      )}${generateGroupings(groupings)}`;
      const target = url.resolve(this.gatewayUrl, path);
      const requestParams = url.parse(target);
      const httpModule = isHttps(requestParams.href) ? https : http;
      const options = Object.assign(requestParams, this.requestOptions, {
        method
      });
      return new Promise((resolve, reject) => {
        const req = httpModule.request(options, (resp) => {
          let body = "";
          resp.setEncoding("utf8");
          resp.on("data", (chunk) => {
            body += chunk;
          });
          resp.on("end", () => {
            resolve({ resp, body });
          });
        });
        req.on("error", (err) => {
          reject(err);
        });
        if (method !== "DELETE") {
          this.registry.metrics().then((metrics) => {
            if (options.headers && options.headers["Content-Encoding"] === "gzip") {
              metrics = gzipSync(metrics);
            }
            req.write(metrics);
            req.end();
          }).catch((err) => {
            reject(err);
          });
        } else {
          req.end();
        }
      });
    }
    function generateGroupings(groupings) {
      if (!groupings) {
        return "";
      }
      return Object.keys(groupings).map(
        (key) => `/${encodeURIComponent(key)}/${encodeURIComponent(groupings[key])}`
      ).join("");
    }
    function isHttps(href) {
      return href.search(/^https/) !== -1;
    }
    module.exports = Pushgateway;
  }
});

// node_modules/prom-client/lib/bucketGenerators.js
var require_bucketGenerators = __commonJS({
  "node_modules/prom-client/lib/bucketGenerators.js"(exports) {
    "use strict";
    exports.linearBuckets = (start, width, count) => {
      if (count < 1) {
        throw new Error("Linear buckets needs a positive count");
      }
      const buckets = new Array(count);
      for (let i = 0; i < count; i++) {
        buckets[i] = start + i * width;
      }
      return buckets;
    };
    exports.exponentialBuckets = (start, factor, count) => {
      if (start <= 0) {
        throw new Error("Exponential buckets needs a positive start");
      }
      if (count < 1) {
        throw new Error("Exponential buckets needs a positive count");
      }
      if (factor <= 1) {
        throw new Error("Exponential buckets needs a factor greater than 1");
      }
      const buckets = new Array(count);
      for (let i = 0; i < count; i++) {
        buckets[i] = start;
        start *= factor;
      }
      return buckets;
    };
  }
});

// node_modules/prom-client/lib/metrics/processCpuTotal.js
var require_processCpuTotal = __commonJS({
  "node_modules/prom-client/lib/metrics/processCpuTotal.js"(exports, module) {
    "use strict";
    var Counter = require_counter();
    var PROCESS_CPU_USER_SECONDS = "process_cpu_user_seconds_total";
    var PROCESS_CPU_SYSTEM_SECONDS = "process_cpu_system_seconds_total";
    var PROCESS_CPU_SECONDS = "process_cpu_seconds_total";
    module.exports = (registry, config = {}) => {
      const registers = registry ? [registry] : void 0;
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      let lastCpuUsage = process.cpuUsage();
      const cpuUserUsageCounter = new Counter({
        name: namePrefix + PROCESS_CPU_USER_SECONDS,
        help: "Total user CPU time spent in seconds.",
        registers,
        labelNames,
        // Use this one metric's `collect` to set all metrics' values.
        collect() {
          const cpuUsage = process.cpuUsage();
          const userUsageMicros = cpuUsage.user - lastCpuUsage.user;
          const systemUsageMicros = cpuUsage.system - lastCpuUsage.system;
          lastCpuUsage = cpuUsage;
          cpuUserUsageCounter.inc(labels, userUsageMicros / 1e6);
          cpuSystemUsageCounter.inc(labels, systemUsageMicros / 1e6);
          cpuUsageCounter.inc(labels, (userUsageMicros + systemUsageMicros) / 1e6);
        }
      });
      const cpuSystemUsageCounter = new Counter({
        name: namePrefix + PROCESS_CPU_SYSTEM_SECONDS,
        help: "Total system CPU time spent in seconds.",
        registers,
        labelNames
      });
      const cpuUsageCounter = new Counter({
        name: namePrefix + PROCESS_CPU_SECONDS,
        help: "Total user and system CPU time spent in seconds.",
        registers,
        labelNames
      });
    };
    module.exports.metricNames = [
      PROCESS_CPU_USER_SECONDS,
      PROCESS_CPU_SYSTEM_SECONDS,
      PROCESS_CPU_SECONDS
    ];
  }
});

// node_modules/prom-client/lib/metrics/processStartTime.js
var require_processStartTime = __commonJS({
  "node_modules/prom-client/lib/metrics/processStartTime.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var startInSeconds = Math.round(Date.now() / 1e3 - process.uptime());
    var PROCESS_START_TIME = "process_start_time_seconds";
    module.exports = (registry, config = {}) => {
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + PROCESS_START_TIME,
        help: "Start time of the process since unix epoch in seconds.",
        registers: registry ? [registry] : void 0,
        labelNames,
        aggregator: "omit",
        collect() {
          this.set(labels, startInSeconds);
        }
      });
    };
    module.exports.metricNames = [PROCESS_START_TIME];
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js
var require_osMemoryHeapLinux = __commonJS({
  "node_modules/prom-client/lib/metrics/osMemoryHeapLinux.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var fs = require_fs();
    var values = ["VmSize", "VmRSS", "VmData"];
    var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
    var PROCESS_VIRTUAL_MEMORY = "process_virtual_memory_bytes";
    var PROCESS_HEAP = "process_heap_bytes";
    function structureOutput(input) {
      const returnValue = {};
      input.split("\n").filter((s) => values.some((value) => s.indexOf(value) === 0)).forEach((string) => {
        const split = string.split(":");
        let value = split[1].trim();
        value = value.substr(0, value.length - 3);
        value = Number(value) * 1024;
        returnValue[split[0]] = value;
      });
      return returnValue;
    }
    module.exports = (registry, config = {}) => {
      const registers = registry ? [registry] : void 0;
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      const residentMemGauge = new Gauge({
        name: namePrefix + PROCESS_RESIDENT_MEMORY,
        help: "Resident memory size in bytes.",
        registers,
        labelNames,
        // Use this one metric's `collect` to set all metrics' values.
        collect() {
          try {
            const stat = fs.readFileSync("/proc/self/status", "utf8");
            const structuredOutput = structureOutput(stat);
            residentMemGauge.set(labels, structuredOutput.VmRSS);
            virtualMemGauge.set(labels, structuredOutput.VmSize);
            heapSizeMemGauge.set(labels, structuredOutput.VmData);
          } catch {
          }
        }
      });
      const virtualMemGauge = new Gauge({
        name: namePrefix + PROCESS_VIRTUAL_MEMORY,
        help: "Virtual memory size in bytes.",
        registers,
        labelNames
      });
      const heapSizeMemGauge = new Gauge({
        name: namePrefix + PROCESS_HEAP,
        help: "Process heap size in bytes.",
        registers,
        labelNames
      });
    };
    module.exports.metricNames = [
      PROCESS_RESIDENT_MEMORY,
      PROCESS_VIRTUAL_MEMORY,
      PROCESS_HEAP
    ];
  }
});

// node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js
var require_safeMemoryUsage = __commonJS({
  "node_modules/prom-client/lib/metrics/helpers/safeMemoryUsage.js"(exports, module) {
    "use strict";
    function safeMemoryUsage() {
      try {
        return process.memoryUsage();
      } catch {
        return;
      }
    }
    module.exports = safeMemoryUsage;
  }
});

// node_modules/prom-client/lib/metrics/osMemoryHeap.js
var require_osMemoryHeap = __commonJS({
  "node_modules/prom-client/lib/metrics/osMemoryHeap.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var linuxVariant = require_osMemoryHeapLinux();
    var safeMemoryUsage = require_safeMemoryUsage();
    var PROCESS_RESIDENT_MEMORY = "process_resident_memory_bytes";
    function notLinuxVariant(registry, config = {}) {
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + PROCESS_RESIDENT_MEMORY,
        help: "Resident memory size in bytes.",
        registers: registry ? [registry] : void 0,
        labelNames,
        collect() {
          const memUsage = safeMemoryUsage();
          if (memUsage) {
            this.set(labels, memUsage.rss);
          }
        }
      });
    }
    module.exports = (registry, config) => process.platform === "linux" ? linuxVariant(registry, config) : notLinuxVariant(registry, config);
    module.exports.metricNames = process.platform === "linux" ? linuxVariant.metricNames : [PROCESS_RESIDENT_MEMORY];
  }
});

// browser-external:process
var require_process = __commonJS({
  "browser-external:process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "process" has been externalized for browser compatibility. Cannot access "process.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js
var require_processOpenFileDescriptors = __commonJS({
  "node_modules/prom-client/lib/metrics/processOpenFileDescriptors.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var fs = require_fs();
    var process2 = require_process();
    var PROCESS_OPEN_FDS = "process_open_fds";
    module.exports = (registry, config = {}) => {
      if (process2.platform !== "linux") {
        return;
      }
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + PROCESS_OPEN_FDS,
        help: "Number of open file descriptors.",
        registers: registry ? [registry] : void 0,
        labelNames,
        collect() {
          try {
            const fds = fs.readdirSync("/proc/self/fd");
            this.set(labels, fds.length - 1);
          } catch {
          }
        }
      });
    };
    module.exports.metricNames = [PROCESS_OPEN_FDS];
  }
});

// node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js
var require_processMaxFileDescriptors = __commonJS({
  "node_modules/prom-client/lib/metrics/processMaxFileDescriptors.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var fs = require_fs();
    var PROCESS_MAX_FDS = "process_max_fds";
    var maxFds;
    module.exports = (registry, config = {}) => {
      if (maxFds === void 0) {
        try {
          const limits = fs.readFileSync("/proc/self/limits", "utf8");
          const lines = limits.split("\n");
          for (const line of lines) {
            if (line.startsWith("Max open files")) {
              const parts = line.split(/  +/);
              maxFds = Number(parts[1]);
              break;
            }
          }
        } catch {
          return;
        }
      }
      if (maxFds === void 0) return;
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + PROCESS_MAX_FDS,
        help: "Maximum number of open file descriptors.",
        registers: registry ? [registry] : void 0,
        labelNames,
        collect() {
          if (maxFds !== void 0) this.set(labels, maxFds);
        }
      });
    };
    module.exports.metricNames = [PROCESS_MAX_FDS];
  }
});

// browser-external:perf_hooks
var require_perf_hooks = __commonJS({
  "browser-external:perf_hooks"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "perf_hooks" has been externalized for browser compatibility. Cannot access "perf_hooks.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/metrics/eventLoopLag.js
var require_eventLoopLag = __commonJS({
  "node_modules/prom-client/lib/metrics/eventLoopLag.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var perf_hooks;
    try {
      perf_hooks = require_perf_hooks();
    } catch {
    }
    var NODEJS_EVENTLOOP_LAG = "nodejs_eventloop_lag_seconds";
    var NODEJS_EVENTLOOP_LAG_MIN = "nodejs_eventloop_lag_min_seconds";
    var NODEJS_EVENTLOOP_LAG_MAX = "nodejs_eventloop_lag_max_seconds";
    var NODEJS_EVENTLOOP_LAG_MEAN = "nodejs_eventloop_lag_mean_seconds";
    var NODEJS_EVENTLOOP_LAG_STDDEV = "nodejs_eventloop_lag_stddev_seconds";
    var NODEJS_EVENTLOOP_LAG_P50 = "nodejs_eventloop_lag_p50_seconds";
    var NODEJS_EVENTLOOP_LAG_P90 = "nodejs_eventloop_lag_p90_seconds";
    var NODEJS_EVENTLOOP_LAG_P99 = "nodejs_eventloop_lag_p99_seconds";
    function reportEventloopLag(start, gauge, labels) {
      const delta = process.hrtime(start);
      const nanosec = delta[0] * 1e9 + delta[1];
      const seconds = nanosec / 1e9;
      gauge.set(labels, seconds);
    }
    module.exports = (registry, config = {}) => {
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      const registers = registry ? [registry] : void 0;
      let collect;
      if (!perf_hooks || !perf_hooks.monitorEventLoopDelay) {
        collect = () => {
          const start = process.hrtime();
          setImmediate(reportEventloopLag, start, lag, labels);
        };
      } else {
        const histogram = perf_hooks.monitorEventLoopDelay({
          resolution: config.eventLoopMonitoringPrecision
        });
        histogram.enable();
        collect = () => {
          const start = process.hrtime();
          setImmediate(reportEventloopLag, start, lag, labels);
          lagMin.set(labels, histogram.min / 1e9);
          lagMax.set(labels, histogram.max / 1e9);
          lagMean.set(labels, histogram.mean / 1e9);
          lagStddev.set(labels, histogram.stddev / 1e9);
          lagP50.set(labels, histogram.percentile(50) / 1e9);
          lagP90.set(labels, histogram.percentile(90) / 1e9);
          lagP99.set(labels, histogram.percentile(99) / 1e9);
          histogram.reset();
        };
      }
      const lag = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG,
        help: "Lag of event loop in seconds.",
        registers,
        labelNames,
        aggregator: "average",
        // Use this one metric's `collect` to set all metrics' values.
        collect
      });
      const lagMin = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_MIN,
        help: "The minimum recorded event loop delay.",
        registers,
        labelNames,
        aggregator: "min"
      });
      const lagMax = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_MAX,
        help: "The maximum recorded event loop delay.",
        registers,
        labelNames,
        aggregator: "max"
      });
      const lagMean = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_MEAN,
        help: "The mean of the recorded event loop delays.",
        registers,
        labelNames,
        aggregator: "average"
      });
      const lagStddev = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_STDDEV,
        help: "The standard deviation of the recorded event loop delays.",
        registers,
        labelNames,
        aggregator: "average"
      });
      const lagP50 = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_P50,
        help: "The 50th percentile of the recorded event loop delays.",
        registers,
        labelNames,
        aggregator: "average"
      });
      const lagP90 = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_P90,
        help: "The 90th percentile of the recorded event loop delays.",
        registers,
        labelNames,
        aggregator: "average"
      });
      const lagP99 = new Gauge({
        name: namePrefix + NODEJS_EVENTLOOP_LAG_P99,
        help: "The 99th percentile of the recorded event loop delays.",
        registers,
        labelNames,
        aggregator: "average"
      });
    };
    module.exports.metricNames = [
      NODEJS_EVENTLOOP_LAG,
      NODEJS_EVENTLOOP_LAG_MIN,
      NODEJS_EVENTLOOP_LAG_MAX,
      NODEJS_EVENTLOOP_LAG_MEAN,
      NODEJS_EVENTLOOP_LAG_STDDEV,
      NODEJS_EVENTLOOP_LAG_P50,
      NODEJS_EVENTLOOP_LAG_P90,
      NODEJS_EVENTLOOP_LAG_P99
    ];
  }
});

// node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js
var require_processMetricsHelpers = __commonJS({
  "node_modules/prom-client/lib/metrics/helpers/processMetricsHelpers.js"(exports, module) {
    "use strict";
    function aggregateByObjectName(list) {
      const data = {};
      for (let i = 0; i < list.length; i++) {
        const listElement = list[i];
        if (!listElement || typeof listElement.constructor === "undefined") {
          continue;
        }
        if (Object.hasOwnProperty.call(data, listElement.constructor.name)) {
          data[listElement.constructor.name] += 1;
        } else {
          data[listElement.constructor.name] = 1;
        }
      }
      return data;
    }
    function updateMetrics(gauge, data, labels) {
      gauge.reset();
      for (const key in data) {
        gauge.set(Object.assign({ type: key }, labels || {}), data[key]);
      }
    }
    module.exports = {
      aggregateByObjectName,
      updateMetrics
    };
  }
});

// node_modules/prom-client/lib/metrics/processHandles.js
var require_processHandles = __commonJS({
  "node_modules/prom-client/lib/metrics/processHandles.js"(exports, module) {
    "use strict";
    var { aggregateByObjectName } = require_processMetricsHelpers();
    var { updateMetrics } = require_processMetricsHelpers();
    var Gauge = require_gauge();
    var NODEJS_ACTIVE_HANDLES = "nodejs_active_handles";
    var NODEJS_ACTIVE_HANDLES_TOTAL = "nodejs_active_handles_total";
    module.exports = (registry, config = {}) => {
      if (typeof process._getActiveHandles !== "function") {
        return;
      }
      const registers = registry ? [registry] : void 0;
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + NODEJS_ACTIVE_HANDLES,
        help: "Number of active libuv handles grouped by handle type. Every handle type is C++ class name.",
        labelNames: ["type", ...labelNames],
        registers,
        collect() {
          const handles = process._getActiveHandles();
          updateMetrics(this, aggregateByObjectName(handles), labels);
        }
      });
      new Gauge({
        name: namePrefix + NODEJS_ACTIVE_HANDLES_TOTAL,
        help: "Total number of active handles.",
        registers,
        labelNames,
        collect() {
          const handles = process._getActiveHandles();
          this.set(labels, handles.length);
        }
      });
    };
    module.exports.metricNames = [
      NODEJS_ACTIVE_HANDLES,
      NODEJS_ACTIVE_HANDLES_TOTAL
    ];
  }
});

// node_modules/prom-client/lib/metrics/processRequests.js
var require_processRequests = __commonJS({
  "node_modules/prom-client/lib/metrics/processRequests.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var { aggregateByObjectName } = require_processMetricsHelpers();
    var { updateMetrics } = require_processMetricsHelpers();
    var NODEJS_ACTIVE_REQUESTS = "nodejs_active_requests";
    var NODEJS_ACTIVE_REQUESTS_TOTAL = "nodejs_active_requests_total";
    module.exports = (registry, config = {}) => {
      if (typeof process._getActiveRequests !== "function") {
        return;
      }
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + NODEJS_ACTIVE_REQUESTS,
        help: "Number of active libuv requests grouped by request type. Every request type is C++ class name.",
        labelNames: ["type", ...labelNames],
        registers: registry ? [registry] : void 0,
        collect() {
          const requests = process._getActiveRequests();
          updateMetrics(this, aggregateByObjectName(requests), labels);
        }
      });
      new Gauge({
        name: namePrefix + NODEJS_ACTIVE_REQUESTS_TOTAL,
        help: "Total number of active requests.",
        registers: registry ? [registry] : void 0,
        labelNames,
        collect() {
          const requests = process._getActiveRequests();
          this.set(labels, requests.length);
        }
      });
    };
    module.exports.metricNames = [
      NODEJS_ACTIVE_REQUESTS,
      NODEJS_ACTIVE_REQUESTS_TOTAL
    ];
  }
});

// node_modules/prom-client/lib/metrics/processResources.js
var require_processResources = __commonJS({
  "node_modules/prom-client/lib/metrics/processResources.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var { updateMetrics } = require_processMetricsHelpers();
    var NODEJS_ACTIVE_RESOURCES = "nodejs_active_resources";
    var NODEJS_ACTIVE_RESOURCES_TOTAL = "nodejs_active_resources_total";
    module.exports = (registry, config = {}) => {
      if (typeof process.getActiveResourcesInfo !== "function") {
        return;
      }
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + NODEJS_ACTIVE_RESOURCES,
        help: "Number of active resources that are currently keeping the event loop alive, grouped by async resource type.",
        labelNames: ["type", ...labelNames],
        registers: registry ? [registry] : void 0,
        collect() {
          const resources = process.getActiveResourcesInfo();
          const data = {};
          for (let i = 0; i < resources.length; i++) {
            const resource = resources[i];
            if (Object.hasOwn(data, resource)) {
              data[resource] += 1;
            } else {
              data[resource] = 1;
            }
          }
          updateMetrics(this, data, labels);
        }
      });
      new Gauge({
        name: namePrefix + NODEJS_ACTIVE_RESOURCES_TOTAL,
        help: "Total number of active resources.",
        registers: registry ? [registry] : void 0,
        labelNames,
        collect() {
          const resources = process.getActiveResourcesInfo();
          this.set(labels, resources.length);
        }
      });
    };
    module.exports.metricNames = [
      NODEJS_ACTIVE_RESOURCES,
      NODEJS_ACTIVE_RESOURCES_TOTAL
    ];
  }
});

// node_modules/prom-client/lib/metrics/heapSizeAndUsed.js
var require_heapSizeAndUsed = __commonJS({
  "node_modules/prom-client/lib/metrics/heapSizeAndUsed.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var safeMemoryUsage = require_safeMemoryUsage();
    var NODEJS_HEAP_SIZE_TOTAL = "nodejs_heap_size_total_bytes";
    var NODEJS_HEAP_SIZE_USED = "nodejs_heap_size_used_bytes";
    var NODEJS_EXTERNAL_MEMORY = "nodejs_external_memory_bytes";
    module.exports = (registry, config = {}) => {
      if (typeof process.memoryUsage !== "function") {
        return;
      }
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      const registers = registry ? [registry] : void 0;
      const namePrefix = config.prefix ? config.prefix : "";
      const collect = () => {
        const memUsage = safeMemoryUsage();
        if (memUsage) {
          heapSizeTotal.set(labels, memUsage.heapTotal);
          heapSizeUsed.set(labels, memUsage.heapUsed);
          if (memUsage.external !== void 0) {
            externalMemUsed.set(labels, memUsage.external);
          }
        }
      };
      const heapSizeTotal = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE_TOTAL,
        help: "Process heap size from Node.js in bytes.",
        registers,
        labelNames,
        // Use this one metric's `collect` to set all metrics' values.
        collect
      });
      const heapSizeUsed = new Gauge({
        name: namePrefix + NODEJS_HEAP_SIZE_USED,
        help: "Process heap size used from Node.js in bytes.",
        registers,
        labelNames
      });
      const externalMemUsed = new Gauge({
        name: namePrefix + NODEJS_EXTERNAL_MEMORY,
        help: "Node.js external memory size in bytes.",
        registers,
        labelNames
      });
    };
    module.exports.metricNames = [
      NODEJS_HEAP_SIZE_TOTAL,
      NODEJS_HEAP_SIZE_USED,
      NODEJS_EXTERNAL_MEMORY
    ];
  }
});

// browser-external:v8
var require_v8 = __commonJS({
  "browser-external:v8"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "v8" has been externalized for browser compatibility. Cannot access "v8.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js
var require_heapSpacesSizeAndUsed = __commonJS({
  "node_modules/prom-client/lib/metrics/heapSpacesSizeAndUsed.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var v8 = require_v8();
    var METRICS = ["total", "used", "available"];
    var NODEJS_HEAP_SIZE = {};
    METRICS.forEach((metricType) => {
      NODEJS_HEAP_SIZE[metricType] = `nodejs_heap_space_size_${metricType}_bytes`;
    });
    module.exports = (registry, config = {}) => {
      const registers = registry ? [registry] : void 0;
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = ["space", ...Object.keys(labels)];
      const gauges = {};
      METRICS.forEach((metricType) => {
        gauges[metricType] = new Gauge({
          name: namePrefix + NODEJS_HEAP_SIZE[metricType],
          help: `Process heap space size ${metricType} from Node.js in bytes.`,
          labelNames,
          registers
        });
      });
      gauges.total.collect = () => {
        for (const space of v8.getHeapSpaceStatistics()) {
          const spaceName = space.space_name.substr(
            0,
            space.space_name.indexOf("_space")
          );
          gauges.total.set({ space: spaceName, ...labels }, space.space_size);
          gauges.used.set({ space: spaceName, ...labels }, space.space_used_size);
          gauges.available.set(
            { space: spaceName, ...labels },
            space.space_available_size
          );
        }
      };
    };
    module.exports.metricNames = Object.values(NODEJS_HEAP_SIZE);
  }
});

// node_modules/prom-client/lib/metrics/version.js
var require_version = __commonJS({
  "node_modules/prom-client/lib/metrics/version.js"(exports, module) {
    "use strict";
    var Gauge = require_gauge();
    var version = process.version;
    var versionSegments = version.slice(1).split(".").map(Number);
    var NODE_VERSION_INFO = "nodejs_version_info";
    module.exports = (registry, config = {}) => {
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      new Gauge({
        name: namePrefix + NODE_VERSION_INFO,
        help: "Node.js version info.",
        labelNames: ["version", "major", "minor", "patch", ...labelNames],
        registers: registry ? [registry] : void 0,
        aggregator: "first",
        collect() {
          this.labels(
            version,
            versionSegments[0],
            versionSegments[1],
            versionSegments[2],
            ...Object.values(labels)
          ).set(1);
        }
      });
    };
    module.exports.metricNames = [NODE_VERSION_INFO];
  }
});

// node_modules/prom-client/lib/metrics/gc.js
var require_gc = __commonJS({
  "node_modules/prom-client/lib/metrics/gc.js"(exports, module) {
    "use strict";
    var Histogram = require_histogram();
    var perf_hooks;
    try {
      perf_hooks = require_perf_hooks();
    } catch {
    }
    var NODEJS_GC_DURATION_SECONDS = "nodejs_gc_duration_seconds";
    var DEFAULT_GC_DURATION_BUCKETS = [1e-3, 0.01, 0.1, 1, 2, 5];
    var kinds = [];
    if (perf_hooks && perf_hooks.constants) {
      kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR] = "major";
      kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR] = "minor";
      kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL] = "incremental";
      kinds[perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB] = "weakcb";
    }
    module.exports = (registry, config = {}) => {
      if (!perf_hooks) {
        return;
      }
      const namePrefix = config.prefix ? config.prefix : "";
      const labels = config.labels ? config.labels : {};
      const labelNames = Object.keys(labels);
      const buckets = config.gcDurationBuckets ? config.gcDurationBuckets : DEFAULT_GC_DURATION_BUCKETS;
      const gcHistogram = new Histogram({
        name: namePrefix + NODEJS_GC_DURATION_SECONDS,
        help: "Garbage collection duration by kind, one of major, minor, incremental or weakcb.",
        labelNames: ["kind", ...labelNames],
        buckets,
        registers: registry ? [registry] : void 0
      });
      const obs = new perf_hooks.PerformanceObserver((list) => {
        const entry = list.getEntries()[0];
        const kind = entry.detail ? kinds[entry.detail.kind] : kinds[entry.kind];
        gcHistogram.observe(Object.assign({ kind }, labels), entry.duration / 1e3);
      });
      obs.observe({ entryTypes: ["gc"] });
    };
    module.exports.metricNames = [NODEJS_GC_DURATION_SECONDS];
  }
});

// node_modules/prom-client/lib/defaultMetrics.js
var require_defaultMetrics = __commonJS({
  "node_modules/prom-client/lib/defaultMetrics.js"(exports, module) {
    "use strict";
    var { isObject } = require_util();
    var processCpuTotal = require_processCpuTotal();
    var processStartTime = require_processStartTime();
    var osMemoryHeap = require_osMemoryHeap();
    var processOpenFileDescriptors = require_processOpenFileDescriptors();
    var processMaxFileDescriptors = require_processMaxFileDescriptors();
    var eventLoopLag = require_eventLoopLag();
    var processHandles = require_processHandles();
    var processRequests = require_processRequests();
    var processResources = require_processResources();
    var heapSizeAndUsed = require_heapSizeAndUsed();
    var heapSpacesSizeAndUsed = require_heapSpacesSizeAndUsed();
    var version = require_version();
    var gc = require_gc();
    var metrics = {
      processCpuTotal,
      processStartTime,
      osMemoryHeap,
      processOpenFileDescriptors,
      processMaxFileDescriptors,
      eventLoopLag,
      ...typeof process.getActiveResourcesInfo === "function" ? { processResources } : {},
      processHandles,
      processRequests,
      heapSizeAndUsed,
      heapSpacesSizeAndUsed,
      version,
      gc
    };
    var metricsList = Object.keys(metrics);
    module.exports = function collectDefaultMetrics(config) {
      if (config !== null && config !== void 0 && !isObject(config)) {
        throw new TypeError("config must be null, undefined, or an object");
      }
      config = { eventLoopMonitoringPrecision: 10, ...config };
      for (const metric of Object.values(metrics)) {
        metric(config.register, config);
      }
    };
    module.exports.metricsList = metricsList;
  }
});

// node_modules/prom-client/lib/metricAggregators.js
var require_metricAggregators = __commonJS({
  "node_modules/prom-client/lib/metricAggregators.js"(exports) {
    "use strict";
    var { Grouper, hashObject } = require_util();
    function AggregatorFactory(aggregatorFn) {
      return (metrics) => {
        if (metrics.length === 0) return;
        const result = {
          help: metrics[0].help,
          name: metrics[0].name,
          type: metrics[0].type,
          values: [],
          aggregator: metrics[0].aggregator
        };
        const byLabels = new Grouper();
        metrics.forEach((metric) => {
          metric.values.forEach((value) => {
            const key = hashObject(value.labels);
            byLabels.add(`${value.metricName}_${key}`, value);
          });
        });
        byLabels.forEach((values) => {
          if (values.length === 0) return;
          const valObj = {
            value: aggregatorFn(values),
            labels: values[0].labels
          };
          if (values[0].metricName) {
            valObj.metricName = values[0].metricName;
          }
          result.values.push(valObj);
        });
        return result;
      };
    }
    exports.AggregatorFactory = AggregatorFactory;
    exports.aggregators = {
      /**
       * @return The sum of values.
       */
      sum: AggregatorFactory((v) => v.reduce((p, c) => p + c.value, 0)),
      /**
       * @return The first value.
       */
      first: AggregatorFactory((v) => v[0].value),
      /**
       * @return {undefined} Undefined; omits the metric.
       */
      omit: () => {
      },
      /**
       * @return The arithmetic mean of the values.
       */
      average: AggregatorFactory(
        (v) => v.reduce((p, c) => p + c.value, 0) / v.length
      ),
      /**
       * @return The minimum of the values.
       */
      min: AggregatorFactory(
        (v) => v.reduce((p, c) => Math.min(p, c.value), Infinity)
      ),
      /**
       * @return The maximum of the values.
       */
      max: AggregatorFactory(
        (v) => v.reduce((p, c) => Math.max(p, c.value), -Infinity)
      )
    };
  }
});

// browser-external:cluster
var require_cluster = __commonJS({
  "browser-external:cluster"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "cluster" has been externalized for browser compatibility. Cannot access "cluster.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/prom-client/lib/cluster.js
var require_cluster2 = __commonJS({
  "node_modules/prom-client/lib/cluster.js"(exports, module) {
    "use strict";
    var Registry = require_registry();
    var { Grouper } = require_util();
    var { aggregators } = require_metricAggregators();
    var cluster = () => {
      const data = require_cluster();
      cluster = () => data;
      return data;
    };
    var GET_METRICS_REQ = "prom-client:getMetricsReq";
    var GET_METRICS_RES = "prom-client:getMetricsRes";
    var registries = [Registry.globalRegistry];
    var requestCtr = 0;
    var listenersAdded = false;
    var requests = /* @__PURE__ */ new Map();
    var AggregatorRegistry = class extends Registry {
      constructor() {
        super();
        addListeners();
      }
      /**
       * Gets aggregated metrics for all workers. The optional callback and
       * returned Promise resolve with the same value; either may be used.
       * @return {Promise<string>} Promise that resolves with the aggregated
       *   metrics.
       */
      clusterMetrics() {
        const requestId = requestCtr++;
        return new Promise((resolve, reject) => {
          let settled = false;
          function done(err, result) {
            if (settled) return;
            settled = true;
            if (err) reject(err);
            else resolve(result);
          }
          const request = {
            responses: [],
            pending: 0,
            done,
            errorTimeout: setTimeout(() => {
              const err = new Error("Operation timed out.");
              request.done(err);
            }, 5e3)
          };
          requests.set(requestId, request);
          const message = {
            type: GET_METRICS_REQ,
            requestId
          };
          for (const id in cluster().workers) {
            if (cluster().workers[id].isConnected()) {
              cluster().workers[id].send(message);
              request.pending++;
            }
          }
          if (request.pending === 0) {
            clearTimeout(request.errorTimeout);
            process.nextTick(() => done(null, ""));
          }
        });
      }
      /**
       * Creates a new Registry instance from an array of metrics that were
       * created by `registry.getMetricsAsJSON()`. Metrics are aggregated using
       * the method specified by their `aggregator` property, or by summation if
       * `aggregator` is undefined.
       * @param {Array} metricsArr Array of metrics, each of which created by
       *   `registry.getMetricsAsJSON()`.
       * @return {Registry} aggregated registry.
       */
      static aggregate(metricsArr) {
        const aggregatedRegistry = new Registry();
        const metricsByName = new Grouper();
        metricsArr.forEach((metrics) => {
          metrics.forEach((metric) => {
            metricsByName.add(metric.name, metric);
          });
        });
        metricsByName.forEach((metrics) => {
          const aggregatorName = metrics[0].aggregator;
          const aggregatorFn = aggregators[aggregatorName];
          if (typeof aggregatorFn !== "function") {
            throw new Error(`'${aggregatorName}' is not a defined aggregator.`);
          }
          const aggregatedMetric = aggregatorFn(metrics);
          if (aggregatedMetric) {
            const aggregatedMetricWrapper = Object.assign(
              {
                get: () => aggregatedMetric
              },
              aggregatedMetric
            );
            aggregatedRegistry.registerMetric(aggregatedMetricWrapper);
          }
        });
        return aggregatedRegistry;
      }
      /**
       * Sets the registry or registries to be aggregated. Call from workers to
       * use a registry/registries other than the default global registry.
       * @param {Array<Registry>|Registry} regs Registry or registries to be
       *   aggregated.
       * @return {void}
       */
      static setRegistries(regs) {
        if (!Array.isArray(regs)) regs = [regs];
        regs.forEach((reg) => {
          if (!(reg instanceof Registry)) {
            throw new TypeError(`Expected Registry, got ${typeof reg}`);
          }
        });
        registries = regs;
      }
    };
    function addListeners() {
      if (listenersAdded) return;
      listenersAdded = true;
      if (cluster().isMaster) {
        cluster().on("message", (worker, message) => {
          if (message.type === GET_METRICS_RES) {
            const request = requests.get(message.requestId);
            if (message.error) {
              request.done(new Error(message.error));
              return;
            }
            message.metrics.forEach((registry) => request.responses.push(registry));
            request.pending--;
            if (request.pending === 0) {
              requests.delete(message.requestId);
              clearTimeout(request.errorTimeout);
              const registry = AggregatorRegistry.aggregate(request.responses);
              const promString = registry.metrics();
              request.done(null, promString);
            }
          }
        });
      }
      if (cluster().isWorker) {
        process.on("message", (message) => {
          if (message.type === GET_METRICS_REQ) {
            Promise.all(registries.map((r) => r.getMetricsAsJSON())).then((metrics) => {
              process.send({
                type: GET_METRICS_RES,
                requestId: message.requestId,
                metrics
              });
            }).catch((error) => {
              process.send({
                type: GET_METRICS_RES,
                requestId: message.requestId,
                error: error.message
              });
            });
          }
        });
      }
    }
    module.exports = AggregatorRegistry;
  }
});

// node_modules/prom-client/index.js
var require_prom_client = __commonJS({
  "node_modules/prom-client/index.js"(exports) {
    exports.register = require_registry().globalRegistry;
    exports.Registry = require_registry();
    exports.contentType = require_registry().globalRegistry.contentType;
    exports.validateMetricName = require_validation().validateMetricName;
    exports.Counter = require_counter();
    exports.Gauge = require_gauge();
    exports.Histogram = require_histogram();
    exports.Summary = require_summary();
    exports.Pushgateway = require_pushgateway();
    exports.linearBuckets = require_bucketGenerators().linearBuckets;
    exports.exponentialBuckets = require_bucketGenerators().exponentialBuckets;
    exports.collectDefaultMetrics = require_defaultMetrics();
    exports.aggregators = require_metricAggregators().aggregators;
    exports.AggregatorRegistry = require_cluster2();
  }
});
export default require_prom_client();
//# sourceMappingURL=prom-client.js.map
